name: 'Terraform ECS Deployment Pipeline'

on:
  pull_request:
    branches: [ main ]
    paths:
      - 'infra/**'
      - 'app.py'
      - 'requirements.txt'
      - 'Dockerfile'
      - 'templates/**'
  push:
    branches: [ main ]
    paths:
      - 'infra/**'
      - 'app.py'
      - 'requirements.txt'
      - 'Dockerfile'
      - 'templates/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.10.0

permissions:
  id-token: write
  contents: read
  pull-requests: write

jobs:
  validate:
    name: 'Terraform Validate & Plan'
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.environment || 'dev' }}

    outputs:
      tfplanExitCode: ${{ steps.tf-plan.outputs.exitcode }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/terraform-aws-ecs-webapp
        role-session-name: GitHub_to_AWS_via_FederatedOIDC
        aws-region: ${{ env.AWS_REGION }}

    - name: Verify AWS Identity
      run: |
        aws sts get-caller-identity
        echo "AWS Region: $AWS_REGION"

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Terraform Format Check
      id: fmt
      working-directory: ./infra
      run: terraform fmt -check -recursive
      continue-on-error: true

    - name: Terraform Init
      id: init
      working-directory: ./infra
      run: terraform init

    - name: Terraform Validate
      id: validate
      working-directory: ./infra
      run: terraform validate

    - name: Terraform Plan
      id: tf-plan
      working-directory: ./infra
      run: |
        terraform plan -detailed-exitcode -out=tfplan
        exitcode=$?

        echo "Terraform plan exit code: $exitcode"
        echo "exitcode=$exitcode" >> "$GITHUB_OUTPUT"

        if [ "$exitcode" -eq 1 ]; then
          echo "Terraform Plan Failed ‚ùå"
          exit 1
        else
          exit 0
        fi

    - name: Publish Terraform Plan
      uses: actions/upload-artifact@v4
      with:
        name: tfplan
        path: ./infra/tfplan

    - name: Create String Output
      id: tf-plan-string
      working-directory: ./infra
      run: |
        TERRAFORM_PLAN=$(terraform show tfplan)

        delimiter="$(openssl rand -hex 8)"
        echo "summary<<${delimiter}" >> $GITHUB_OUTPUT
        echo "## Terraform Plan Output" >> $GITHUB_OUTPUT
        echo "<details><summary>Click to expand</summary>" >> $GITHUB_OUTPUT
        echo "" >> $GITHUB_OUTPUT
        echo '```terraform' >> $GITHUB_OUTPUT
        echo "$TERRAFORM_PLAN" >> $GITHUB_OUTPUT
        echo '```' >> $GITHUB_OUTPUT
        echo "</details>" >> $GITHUB_OUTPUT
        echo "${delimiter}" >> $GITHUB_OUTPUT

    - name: Publish Terraform Plan to Task Summary
      env:
        SUMMARY: ${{ steps.tf-plan-string.outputs.summary }}
      run: |
        echo "$SUMMARY" >> $GITHUB_STEP_SUMMARY

    - name: Comment PR
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      env:
        SUMMARY: "${{ steps.tf-plan-string.outputs.summary }}"
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const body = `${process.env.SUMMARY}`;

          // List comments
          const comments = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
          })

          // Find existing comment
          const botComment = comments.data.find(comment => {
            return comment.user.type === 'Bot' && comment.body.includes('Terraform Plan Output')
          })

          if (botComment) {
            github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: body
            })
          } else {
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            })
          }

  security-scan:
    name: 'Security Scanning'
    runs-on: ubuntu-latest
    needs: validate
    if: needs.validate.outputs.tfplanExitCode == '2'

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Run Checkov
      id: checkov
      uses: bridgecrewio/checkov-action@v12
      with:
        directory: ./infra
        framework: terraform
        output_format: cli,json
        output_file_path: console,results_checkov.json
        soft_fail: true

    - name: Upload Checkov Results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: checkov-report
        path: results_checkov.json

  build-and-push:
    name: 'Build & Push Docker Image'
    runs-on: ubuntu-latest
    needs: [validate, security-scan]
    if: |
      always() &&
      needs.validate.result == 'success' &&
      (
      github.event_name == 'workflow_dispatch' ||
      github.ref == 'refs/heads/main'
      )
    environment:
      name: ${{ github.event.inputs.environment || 'dev' }}

    outputs:
      image-tag: ${{ steps.image-tag.outputs.tag }}
      ecr-repository: ${{ steps.ecr-info.outputs.repository }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/terraform-aws-ecs-webapp
        role-session-name: GitHub_to_AWS_via_FederatedOIDC
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Generate Image Tag
      id: image-tag
      run: |
        # Use short commit SHA for image tag
        TAG=${GITHUB_SHA::7}
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "Generated image tag: $TAG"

    - name: Set ECR Repository Info
      id: ecr-info
      run: |
        REPO_NAME="sohaibsohail/sohaib-portfolio"
        echo "repository=$REPO_NAME" >> $GITHUB_OUTPUT
        echo "ECR Repository: $REPO_NAME"

    - name: Login to Amazon ECR
      uses: aws-actions/amazon-ecr-login@v2
      with:
        registry-type: private

    - name: Build Docker Image
      run: |
        docker build -t ${{ steps.ecr-info.outputs.repository }}:${{ steps.image-tag.outputs.tag }} .
        docker build -t ${{ steps.ecr-info.outputs.repository }}:latest .

    - name: Tag Docker Image for ECR
      run: |
        docker tag ${{ steps.ecr-info.outputs.repository }}:${{ steps.image-tag.outputs.tag }} \
          ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ steps.ecr-info.outputs.repository }}:${{ steps.image-tag.outputs.tag }}

        docker tag ${{ steps.ecr-info.outputs.repository }}:latest \
          ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ steps.ecr-info.outputs.repository }}:latest

    - name: Push Docker Image to ECR
      run: |
        docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ steps.ecr-info.outputs.repository }}:${{ steps.image-tag.outputs.tag }}
        docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ steps.ecr-info.outputs.repository }}:latest

    - name: Image Build Summary
      run: |
        echo "## üê≥ Docker Image Built Successfully!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Repository:** ${{ steps.ecr-info.outputs.repository }}" >> $GITHUB_STEP_SUMMARY
        echo "**Tag:** ${{ steps.image-tag.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
        echo "**ECR URI:** ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ steps.ecr-info.outputs.repository }}:${{ steps.image-tag.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "‚úÖ Image pushed to ECR successfully" >> $GITHUB_STEP_SUMMARY

  deploy:
    name: 'Terraform Apply'
    runs-on: ubuntu-latest
    needs: [validate, security-scan, build-and-push]
    if: |
      always() &&
      needs.validate.result == 'success' &&
      needs.build-and-push.result == 'success' &&
      (
      github.event_name == 'workflow_dispatch' ||
      github.ref == 'refs/heads/main'
      )
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.tf-output.outputs.load_balancer_url }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/terraform-aws-ecs-webapp
        role-session-name: GitHub_to_AWS_via_FederatedOIDC
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Terraform Init
      working-directory: ./infra
      run: terraform init

    - name: Download Terraform Plan
      uses: actions/download-artifact@v4
      with:
        name: tfplan
        path: ./infra

    - name: Terraform Apply
      working-directory: ./infra
      run: terraform apply -auto-approve tfplan

    - name: Get Terraform Outputs
      id: tf-output
      working-directory: ./infra
      run: |
        load_balancer_url=$(terraform output -raw load_balancer_url)
        ecr_repository_url=$(terraform output -raw ecr_repository_url)
        cluster_name=$(terraform output -raw ecs_cluster_name)
        service_name=$(terraform output -raw ecs_service_name)

        echo "load_balancer_url=$load_balancer_url" >> $GITHUB_OUTPUT
        echo "ecr_repository_url=$ecr_repository_url" >> $GITHUB_OUTPUT
        echo "cluster_name=$cluster_name" >> $GITHUB_OUTPUT
        echo "service_name=$service_name" >> $GITHUB_OUTPUT

        echo "## üöÄ Deployment Successful!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Portfolio URL:** $load_balancer_url" >> $GITHUB_STEP_SUMMARY
        echo "**Snake Game:** $load_balancer_url/game" >> $GITHUB_STEP_SUMMARY
        echo "**Health Check:** $load_balancer_url/health" >> $GITHUB_STEP_SUMMARY
        echo "**ECR Repository:** $ecr_repository_url" >> $GITHUB_STEP_SUMMARY
        echo "**Docker Image:** ${{ needs.build-and-push.outputs.ecr-repository }}:${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY


    - name: Application Health Check
      run: |
        echo "Waiting for application to be ready..."
        sleep 60

        # Try health check with retries
        for i in {1..10}; do
          if curl -f "${{ steps.tf-output.outputs.load_balancer_url }}/health" > /dev/null 2>&1; then
            echo "‚úÖ Application is healthy!"
            break
          else
            echo "‚è≥ Attempt $i/10: Application not ready yet, waiting..."
            sleep 30
          fi

          if [ $i -eq 10 ]; then
            echo "‚ùå Application health check failed after 10 attempts"
            exit 1
          fi
        done

